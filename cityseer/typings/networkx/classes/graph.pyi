"""
This type stub file was generated by pyright.
"""

"""Base class for undirected graphs"""
__all__ = ["Graph"]
class Graph:
    """
    Base class for undirected g"""
    node_dict_factory = ...
    node_attr_dict_factory = ...
    adjlist_outer_dict_factory = ...
    adjlist_inner_dict_factory = ...
    edge_attr_dict_factory = ...
    graph_attr_dict_factory = ...
    def to_directed_class(self): # -> Type[DiGraph]:
        """Returns the class to use for emp"""
        ...
    
    def to_undirected_class(self): # -> Type[Graph]:
        """Returns the class to use for emp"""
        ...
    
    def __init__(self, incoming_graph_data=..., **attr) -> None:
        """Initialize a graph with edges, n"""
        ...
    
    @property
    def adj(self): # -> AdjacencyView:
        """Graph adjacency object holding t"""
        ...
    
    @property
    def name(self): # -> str:
        """String identifier of the graph.
"""
        ...
    
    @name.setter
    def name(self, s): # -> None:
        ...
    
    def __str__(self) -> str:
        """Returns a short summary of the g"""
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        """Iterate over the nodes. Use: 'fo"""
        ...
    
    def __contains__(self, n): # -> bool:
        """Returns True if n is a node, Fal"""
        ...
    
    def __len__(self): # -> int:
        """Returns the number of nodes in t"""
        ...
    
    def __getitem__(self, n): # -> AtlasView:
        """Returns a dict of neighbors of n"""
        ...
    
    def add_node(self, node_for_adding, **attr): # -> None:
        """Add a single node `node_for_addi"""
        ...
    
    def add_nodes_from(self, nodes_for_adding, **attr): # -> None:
        """Add multiple nodes.

        Par"""
        ...
    
    def remove_node(self, n): # -> None:
        """Remove node n.

        Removes """
        ...
    
    def remove_nodes_from(self, nodes): # -> None:
        """Remove multiple nodes.

        """
        ...
    
    @property
    def nodes(self): # -> NodeView:
        """A NodeView of the Graph as G.nod"""
        ...
    
    def number_of_nodes(self): # -> int:
        """Returns the number of nodes in t"""
        ...
    
    def order(self): # -> int:
        """Returns the number of nodes in t"""
        ...
    
    def has_node(self, n): # -> bool:
        """Returns True if the graph contai"""
        ...
    
    def add_edge(self, u_of_edge, v_of_edge, **attr): # -> None:
        """Add an edge between u and v.

  """
        ...
    
    def add_edges_from(self, ebunch_to_add, **attr): # -> None:
        """Add all the edges in ebunch_to_a"""
        ...
    
    def add_weighted_edges_from(self, ebunch_to_add, weight=..., **attr): # -> None:
        """Add weighted edges in `ebunch_to"""
        ...
    
    def remove_edge(self, u, v): # -> None:
        """Remove the edge between u and v."""
        ...
    
    def remove_edges_from(self, ebunch): # -> None:
        """Remove all edges specified in eb"""
        ...
    
    def update(self, edges=..., nodes=...): # -> None:
        """Update the graph using nodes/edg"""
        ...
    
    def has_edge(self, u, v): # -> bool:
        """Returns True if the edge (u, v) """
        ...
    
    def neighbors(self, n):
        """Returns an iterator over all nei"""
        ...
    
    @property
    def edges(self): # -> EdgeView:
        """An EdgeView of the Graph as G.ed"""
        ...
    
    def get_edge_data(self, u, v, default=...): # -> None:
        """Returns the attribute dictionary"""
        ...
    
    def adjacency(self): # -> Iterator[tuple[Unknown, Unknown]]:
        """Returns an iterator over (node, """
        ...
    
    @property
    def degree(self): # -> DegreeView:
        """A DegreeView for the Graph as G."""
        ...
    
    def clear(self): # -> None:
        """Remove all nodes and edges from """
        ...
    
    def clear_edges(self): # -> None:
        """Remove all edges from the graph """
        ...
    
    def is_multigraph(self): # -> Literal[False]:
        """Returns True if graph is a multi"""
        ...
    
    def is_directed(self): # -> Literal[False]:
        """Returns True if graph is directe"""
        ...
    
    def copy(self, as_view=...): # -> Generator[Unknown, None, None] | Self@Graph:
        """Returns a copy of the graph.

  """
        ...
    
    def to_directed(self, as_view=...): # -> Generator[Unknown, None, None] | DiGraph:
        """Returns a directed representatio"""
        ...
    
    def to_undirected(self, as_view=...): # -> Generator[Unknown, None, None] | Graph:
        """Returns an undirected copy of th"""
        ...
    
    def subgraph(self, nodes):
        """Returns a SubGraph view of the s"""
        ...
    
    def edge_subgraph(self, edges):
        """Returns the subgraph induced by """
        ...
    
    def size(self, weight=...): # -> int | float:
        """Returns the number of edges or t"""
        ...
    
    def number_of_edges(self, u=..., v=...): # -> int:
        """Returns the number of edges betw"""
        ...
    
    def nbunch_iter(self, nbunch=...): # -> Iterator[Unknown] | Generator[Unknown, None, None]:
        """Returns an iterator over nodes c"""
        ...
    


