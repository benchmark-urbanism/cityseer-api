# Motivation

The overarching motivation in the development of `cityseer-api` has been the quantification of urban characteristics in a manner that is as sensitive as possible to local particularities and variations. `cityseer-api` is designed for localised urban analysis at the pedestrian scale, meaning that observations are tailored towards pedestrian walking tolerances, commonly in the range of 400m to 800m, and infrequently exceeding 1,600m. In the case of certain land-use and mixed-use measures, it can be beneficial to work with weighted measures at distance thresholds as small as 100m or even 50m so that metrics are sufficiently precise to be pertinent to the day-to-day decisions made by architects and urban designers. These use-cases require information anchored to particular locations and measures must be adequately sensitive to reflect varying outcomes in response to different scenarios.

Computational methods for network-based centrality and land-use analysis make extensive use of shortest-path algorithms: these present substantial computational complexity due to nested-loops. Centrality methods implemented in pure `python`, such as those contained in [`NetworkX`](https://networkx.github.io/), can be particularly slow and may hinder practical application to large urban street networks. Speed improvements are offered by packages such as [`Graph-Tool`](https://graph-tool.skewed.de), which wrap underlying optimised `C` or `C++` code libraries. This is the approach that earlier variants of `cityseer-api` adopted, but whereas high-performance graph-analysis packages can be co-opted for many forms of urban network analysis they do not necessarily offer the degree of extensibility required for convenient wider experimentation with different algorithmic variations of centrality, mixed-use, land-use accessibility, or statistical calculations that may be more specific to analytics from an urbanist's perspective. Attempts to piggy-back existing packages can therefore lead to a degree of code complexity presenting a bottleneck to further experimentation and development, and it was this conundrum that kickstarted the development of the current codebase that became formalised as the `cityseer-api` package. The present approach leverages pure `python` and [`numpy`](http://www.numpy.org/), but with computationally intensive algorithms optimised through use of [`numba`](https://numba.pydata.org/) JIT compilation. This allowed for wide-ranging experimentation with the underlying algorithms during the development of the author's PhD research, while facilitating code abstraction, reducing duplication, improving maintainability, and facilitating the use of paradigms that are well-suited to pedestrian-scale urban analysis. This flexibility has allowed a range of particular issues to be addressed:

- Localised analysis is based on network methods applied over the graph through means of a 'moving-window', whereby the graph is isolated at specified distance thresholds prior to localised analysis for the currently selected node. These thresholds are conventionally based on either crow-flies euclidean distances or true network distances. `cityseer-api` takes the position that true network distances are more representative when working at smaller pedestrian distance thresholds, particularly when applied to land-use accessibilities and mixed-use calculations;
- It is common to use either shortest-distance or simplest-path (shortest angular 'distance') impedance heuristics. When using simplest-path heuristics, it is necessary to modify the underlying shortest-path algorithms to prevent side-stepping of sharp angular turns, otherwise two smaller side-steps can be combined to 'short-cut' sharp corners. It is also common for methods to be applied to either primal graph representations (generally used with shortest-path methods such as those applied by _multiple centrality assessment_ analysis) or dual graph representations (typically used with simplest-path methods in the tradition of _space syntax_);
- There are a range of possible centrality and mixed-use methods, many of which can be weighted by distances or street lengths. These methods and their implications are explored in detail in the forthcoming _localised land-use diversity_ and _localised land-use diversity methods_ papers. Some conventional methods, even if widely used, have not necessarily proved suitable for localised urban analysis;
- Centrality methods are susceptible to topological distortions arising from 'messy' graph representations as well as due to the conflation of topological and geometrical properties of street networks. `cityseer-api` addresses these through the inclusion of graph cleaning functions; procedures for splitting geometrical properties from topological representations; and the inclusion of segmentised centrality measures, which are less susceptible to distortions introduced by varying intensities of nodes;
- Hyperlocal analysis requires approaches facilitating the evaluation of respective measures at finely-spaced intervals along streetfronts. Further, granular evaluation of land-use accessibilities and mixed-uses requires that landuses be assigned to the street network in a contextually precise manner. These are addressed in `cityseer-api` through application of network decomposition combined with algorithms allowing for bidirectional assignment of data points to network nodes based on the closest adjacent street edge.

The broader emphasis on localised methods and the manner in which `cityseer-api` addresses these is broached in the accompanying paper (link forthcoming). `cityseer-api` includes a variety of convenience methods for the general preparation of networks and for their conversion into (and out of) the lower-level data structures used by the underlying algorithms. These graph utility methods are designed to work with `NetworkX` to facilitate ease-of-use. A complement of code tests has been developed for maintaining the integrity of the code-base through general package maintenance and upgrade cycles. Shortest-path algorithms, harmonic closeness, and betweenness algorithms are tested against `NetworkX`. Mock data and test plots have been used to visually confirm the intended behaviour for divergent simplest and shortest-path heuristics, and for testing data assignment to network nodes given a variety of scenarios.
