---
import Markdown from '@astrojs/markdown-component';
import PageLayout from '@src/layouts/PageLayout.astro'
---
<PageLayout>

<div class="yap module">
  <h1 class="yap module-title" id="cityseer-metrics-networks">
    <a aria-hidden="true" href="#cityseer-metrics-networks" tabindex="-1">
      <svg aria-hidden="true" class="heading-icon" height="15px" viewBox="0 0 20 20" width="15px" xmlns="http://www.w3.org/2000/svg">
        <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
      </svg>
    </a>cityseer.metrics.networks
  </h1><Markdown is:raw>
Compute network centralities.

 There are three network centrality methods available depending on whether you're using a node-based or segment-based approach, with the former available in both shortest and simplest (angular) variants.

- [`node_centrality_shortest`](#node-centrality-shortest)
- [`node_centrality_simplest`](#node-centrality-simplest)
- [`segment_centrality`](#segment-centrality)

 These methods wrap the underlying `rust` optimised functions for computing centralities. Multiple classes of measures and distances are computed simultaneously to reduce the amount of time required for multi-variable and multi-scalar strategies.

 See the accompanying paper on `arXiv` for additional information about methods for computing centrality measures.

:::note
The reasons for picking one approach over another are varied:

- Node based centralities compute the measures relative to each reachable node within the threshold distances. For
this reason, they can be susceptible to distortions caused by messy graph topologies such redundant and varied
concentrations of degree=2 nodes (e.g. to describe roadway geometry) or needlessly complex representations of
street intersections. In these cases, the network should first be cleaned using methods such as those available in
the [`graph`](/tools/graphs) module (see the [graph cleaning guide](/guide#graph-cleaning) for examples). If a
network topology has varied intensities of nodes but the street segments are less spurious, then segmentised methods
can be preferable because they are based on segment distances: segment aggregations remain the same regardless of
the number of intervening nodes, however, are not immune from situations such as needlessly complex representations
of roadway intersections or a proliferation of walking paths in greenspaces;
- Node-based `harmonic` centrality can be problematic on graphs where nodes are erroneously placed too close
together or where impedances otherwise approach zero, as may be the case for simplest-path measures or small
distance thesholds. This happens because the outcome of the division step can balloon towards $\infty$ once
impedances decrease below 1.
- Note that `cityseer`'s implementation of simplest (angular) measures work on both primal and dual graphs (node only).
- Measures should only be directly compared on the same topology because different topologies can otherwise affect
the expression of a measure. Accordingly, measures computed on dual graphs cannot be compared to measures computed
on primal graphs because this does not account for the impact of differing topologies. Dual graph representations
can have substantially greater numbers of nodes and edges for the same underlying street network; for example, a
four-way intersection consisting of one node with four edges translates to four nodes and six edges on the dual.
This effect is amplified for denser regions of the network.
- Segmentised versions of centrality measures should not be computed on dual graph topologies because street segment
lengths would be duplicated for each permutation of dual edge spanning street intersections. By way of example,
the contribution of a single edge segment at a four-way intersection would be duplicated three times.
- Global closeness is strongly discouraged because it does not behave suitably for localised graphs. Harmonic
closeness should be used instead.
- Network decomposition can be a useful strategy when working at small distance thresholds, and confers advantages
such as more regularly spaced snapshots and fewer artefacts at small distance thresholds where street edges
intersect distance thresholds. However, the regular spacing of the decomposed segments will introduce spikes in the
distributions of node-based centrality measures when working at very small distance thresholds. Segmentised versions
may therefore be preferable when working at small thresholds on decomposed networks.
:::
</Markdown>
  <section class="yap func">
    <h2 class="yap func-title" id="node-centrality-shortest">
      <a aria-hidden="true" href="#node-centrality-shortest" tabindex="-1">
        <svg aria-hidden="true" class="heading-icon" height="15px" viewBox="0 0 20 20" width="15px" xmlns="http://www.w3.org/2000/svg">
          <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
        </svg>
      </a>node_centrality_shortest
    </h2>
    <div class="yap func-sig-content">
      <div class="yap func-sig">
        <span>node_centrality_shortest(</span>
        <div class="yap func-sig-params">
          <div class="yap func-sig-param">network_structure, </div>
          <div class="yap func-sig-param">nodes_gdf, </div>
          <div class="yap func-sig-param">distances=None, </div>
          <div class="yap func-sig-param">betas=None, </div>
          <div class="yap func-sig-param">compute_closeness=True, </div>
          <div class="yap func-sig-param">compute_betweenness=True, </div>
          <div class="yap func-sig-param">min_threshold_wt=MIN_THRESH_WT, </div>
          <div class="yap func-sig-param">jitter_scale=0.0)</div>
        </div>
      </div>
    </div>
    <div class="yap"><Markdown is:raw>
Compute node-based network centrality using the shortest path heuristic.
</Markdown>
      <h3 class="yap">Parameters</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">network_structure</div>
          <div class="yap doc-str-elem-type">NetworkStructure</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`rustalgos.NetworkStructure`](/rustalgos#networkstructure). Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`GeoDataFrame`](https://geopandas.org/en/stable/docs/user_guide/data_structures.html#geodataframe) representing nodes. Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method. The outputs of calculations will be written to this `GeoDataFrame`, which is then returned from the method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">distances</div>
          <div class="yap doc-str-elem-type">list[int] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Distances corresponding to the local $d_{max}$ thresholds to be used for calculations. The $\beta$ parameters (for distance-weighted metrics) will be determined implicitly. If the `distances` parameter is not provided, then the `beta` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">betas</div>
          <div class="yap doc-str-elem-type">list[float] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A $\beta$, or array of $\beta$ to be used for the exponential decay function for weighted metrics. The `distance` parameters for unweighted metrics will be determined implicitly. If the `betas` parameter is not provided, then the `distance` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_closeness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute closeness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_betweenness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute betweenness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">min_threshold_wt</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The default `min_threshold_wt` parameter can be overridden to generate custom mappings between the `distance` and `beta` parameters. See [`rustalgos.distances_from_beta`](/rustalgos#distances-from-betas) for more information.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">jitter_scale</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The scale of random jitter to add to shortest path calculations, useful for situations with highly rectilinear grids. `jitter_scale` is passed to the `scale` parameter of `np.random.normal`.
</Markdown></div>
      </div>
      <h3 class="yap">Returns</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The input `node_gdf` parameter is returned with additional columns populated with the calcualted metrics.
</Markdown></div>
      </div>
      <h3 class="yap">Examples</h3><Markdown is:raw>
The following keys use the shortest-path heuristic:

| key                   | formula | notes |
| ----------------------| :------:| ----- |
| node_density          | $$\sum_{j\neq{i}}^{n}1$$ | A summation of nodes. |
| node_farness          | $$\sum_{j\neq{i}}^{n}d_{(i,j)}$$ | A summation of distances in metres. |
| node_cycles           | $$\sum_{j\neq{i}j=cycle}^{n}1$$ | A summation of network cycles. |
| node_harmonic         | $$\sum_{j\neq{i}}^{n}\frac{1}{Z_{(i,j)}}$$ | Harmonic closeness is an appropriate form of closeness centrality for localised implementations constrained by the threshold $d_{max}$. |
| node_beta             | $$\sum_{j\neq{i}}^{n}\exp(-\beta\cdot d[i,j])$$ | Also known as the gravity index. This is a spatial impedance metric differentiated from other closeness centralities by the use of an explicit $\beta$ parameter, which can be used to model the decay in walking tolerance as distances increase. |
| node_betweenness      | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}1$$ | Betweenness centrality summing all shortest-paths traversing each node $i$. |
| node_betweenness_beta | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}\exp(-\beta\cdot d[j,k])$$ | Applies a spatial impedance decay function to betweenness centrality. $d$ represents the full distance from any $j$ to $k$ node pair passing through node $i$. |

The following keys use the simplest-path (shortest-angular-path) heuristic, and are available when the `angular` parameter is explicitly set to `True`:

| key                      | formula | notes |
| ------------------------ | :-----: | ----- |
| node_harmonic_angular    | $$\sum_{j\neq{i}}^{n}\frac{1}{Z_{(i,j)}}$$ | The simplest-path implementation of harmonic closeness uses angular-distances for the impedance parameter. Angular-distances are normalised by 180 and added to 1 to avoid division by zero: ${Z = 1 + (angularchange/180)}$. |
| node_betweenness_angular | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}1$$ | The simplest-path version of betweenness centrality. This is distinguished from the shortest-path version by use of a simplest-path heuristic (shortest angular distance). |
</Markdown>
    </div>
  </section>
  <section class="yap func">
    <h2 class="yap func-title" id="node-centrality-simplest">
      <a aria-hidden="true" href="#node-centrality-simplest" tabindex="-1">
        <svg aria-hidden="true" class="heading-icon" height="15px" viewBox="0 0 20 20" width="15px" xmlns="http://www.w3.org/2000/svg">
          <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
        </svg>
      </a>node_centrality_simplest
    </h2>
    <div class="yap func-sig-content">
      <div class="yap func-sig">
        <span>node_centrality_simplest(</span>
        <div class="yap func-sig-params">
          <div class="yap func-sig-param">network_structure, </div>
          <div class="yap func-sig-param">nodes_gdf, </div>
          <div class="yap func-sig-param">distances=None, </div>
          <div class="yap func-sig-param">betas=None, </div>
          <div class="yap func-sig-param">compute_closeness=True, </div>
          <div class="yap func-sig-param">compute_betweenness=True, </div>
          <div class="yap func-sig-param">min_threshold_wt=MIN_THRESH_WT, </div>
          <div class="yap func-sig-param">jitter_scale=0.0)</div>
        </div>
      </div>
    </div>
    <div class="yap"><Markdown is:raw>
Compute node-based network centrality using the simplest path (angular) heuristic.
</Markdown>
      <h3 class="yap">Parameters</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">network_structure</div>
          <div class="yap doc-str-elem-type">NetworkStructure</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`rustalgos.NetworkStructure`](/rustalgos#networkstructure). Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`GeoDataFrame`](https://geopandas.org/en/stable/docs/user_guide/data_structures.html#geodataframe) representing nodes. Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method. The outputs of calculations will be written to this `GeoDataFrame`, which is then returned from the method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">distances</div>
          <div class="yap doc-str-elem-type">list[int] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Distances corresponding to the local $d_{max}$ thresholds to be used for calculations. The $\beta$ parameters (for distance-weighted metrics) will be determined implicitly. If the `distances` parameter is not provided, then the `beta` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">betas</div>
          <div class="yap doc-str-elem-type">list[float] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A $\beta$, or array of $\beta$ to be used for the exponential decay function for weighted metrics. The `distance` parameters for unweighted metrics will be determined implicitly. If the `betas` parameter is not provided, then the `distance` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_closeness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute closeness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_betweenness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute betweenness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">min_threshold_wt</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The default `min_threshold_wt` parameter can be overridden to generate custom mappings between the `distance` and `beta` parameters. See [`rustalgos.distances_from_beta`](/rustalgos#distances-from-betas) for more information.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">jitter_scale</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The scale of random jitter to add to shortest path calculations, useful for situations with highly rectilinear grids. `jitter_scale` is passed to the `scale` parameter of `np.random.normal`.
</Markdown></div>
      </div>
      <h3 class="yap">Returns</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The input `node_gdf` parameter is returned with additional columns populated with the calcualted metrics.
</Markdown></div>
      </div>
      <h3 class="yap">Examples</h3><Markdown is:raw>
The following keys use the simplest-path heuristic:

| key                   | formula | notes |
| ----------------------| :------:| ----- |
| node_harmonic_simplest    | $$\sum_{j\neq{i}}^{n}\frac{1}{Z_{(i,j)}}$$ | Harmonic closeness is an appropriate form of closeness centrality for localised implementations constrained by the threshold $d_{max}$. |
| node_betweenness_simplest | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}1$$ | Betweenness centrality summing all shortest-paths traversing each node $i$. |

The following keys use the simplest-path (shortest-angular-path) heuristic, and are available when the `angular` parameter is explicitly set to `True`:
</Markdown>
    </div>
  </section>
  <section class="yap func">
    <h2 class="yap func-title" id="segment-centrality">
      <a aria-hidden="true" href="#segment-centrality" tabindex="-1">
        <svg aria-hidden="true" class="heading-icon" height="15px" viewBox="0 0 20 20" width="15px" xmlns="http://www.w3.org/2000/svg">
          <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
        </svg>
      </a>segment_centrality
    </h2>
    <div class="yap func-sig-content">
      <div class="yap func-sig">
        <span>segment_centrality(</span>
        <div class="yap func-sig-params">
          <div class="yap func-sig-param">network_structure, </div>
          <div class="yap func-sig-param">nodes_gdf, </div>
          <div class="yap func-sig-param">distances=None, </div>
          <div class="yap func-sig-param">betas=None, </div>
          <div class="yap func-sig-param">compute_closeness=True, </div>
          <div class="yap func-sig-param">compute_betweenness=True, </div>
          <div class="yap func-sig-param">min_threshold_wt=MIN_THRESH_WT, </div>
          <div class="yap func-sig-param">jitter_scale=0.0)</div>
        </div>
      </div>
    </div>
    <div class="yap"><Markdown is:raw>
Compute segment-based network centrality using the shortest path heuristic.

 > Simplest path heuristics introduce conceptual and practical complications and support is deprecated since v4.
</Markdown>
      <h3 class="yap">Parameters</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">network_structure</div>
          <div class="yap doc-str-elem-type">NetworkStructure</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`rustalgos.NetworkStructure`](/rustalgos#networkstructure). Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A [`GeoDataFrame`](https://geopandas.org/en/stable/docs/user_guide/data_structures.html#geodataframe) representing nodes. Best generated with the [`io.network_structure_from_nx`](/tools/graphs#network-structure-from-nx) method. The outputs of calculations will be written to this `GeoDataFrame`, which is then returned from the method.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">distances</div>
          <div class="yap doc-str-elem-type">list[int] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Distances corresponding to the local $d_{max}$ thresholds to be used for calculations. The $\beta$ parameters (for distance-weighted metrics) will be determined implicitly. If the `distances` parameter is not provided, then the `beta` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">betas</div>
          <div class="yap doc-str-elem-type">list[float] | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
A $\beta$, or array of $\beta$ to be used for the exponential decay function for weighted metrics. The `distance` parameters for unweighted metrics will be determined implicitly. If the `betas` parameter is not provided, then the `distance` parameter must be provided instead.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_closeness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute closeness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">compute_betweenness</div>
          <div class="yap doc-str-elem-type">bool | None</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
Compute betweenness centralities. True by default.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">min_threshold_wt</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The default `min_threshold_wt` parameter can be overridden to generate custom mappings between the `distance` and `beta` parameters. See [`rustalgos.distances_from_beta`](/rustalgos#distances-from-betas) for more information.
</Markdown></div>
      </div>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">jitter_scale</div>
          <div class="yap doc-str-elem-type">float</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The scale of random jitter to add to shortest path calculations, useful for situations with highly rectilinear grids. `jitter_scale` is passed to the `scale` parameter of `np.random.normal`.
</Markdown></div>
      </div>
      <h3 class="yap">Returns</h3>
      <div class="yap doc-str-elem-container">
        <div class="yap doc-str-elem-def">
          <div class="yap doc-str-elem-name">nodes_gdf</div>
          <div class="yap doc-str-elem-type">GeoDataFrame</div>
        </div>
        <div class="yap doc-str-elem-desc"><Markdown is:raw>
The input `node_gdf` parameter is returned with additional columns populated with the calcualted metrics.
</Markdown></div>
      </div>
      <h3 class="yap">Examples</h3><Markdown is:raw>
Segment path centralities are available with the following keys:

| key                 | formula | notes |
| ------------------- | :-----: |------ |
| segment_density     | $$\sum_{(a, b)}^{edges}d_{b} - d_{a}$$ | A summation of edge lengths. |
| segment_harmonic    | $$\sum_{(a, b)}^{edges}\int_{a}^{b}\ln(b) -\ln(a)$$ | A continuous form of harmonic closeness centrality applied to edge lengths. |
| segment_beta        | $$\sum_{(a, b)}^{edges}\int_{a}^{b}\frac{\exp(-\beta\cdot b) -\exp(-\beta\cdot a)}{-\beta}$$ | A continuous form of beta-weighted (gravity index) centrality applied to edge lengths. |
| segment_betweenness | | A continuous form of betweenness: Resembles `segment_beta` applied to edges situated on shortest paths between all nodes $j$ and $k$ passing through $i$. |
</Markdown>
    </div>
  </section>
</div>
</PageLayout>

