---
  import { Markdown } from 'astro/components';
  import ArXivLink from '@src/components/ArXivLink.vue'
  import PageLayout from '@src/layouts/PageLayout.astro'
---

<PageLayout>
  <div class="yap module">
    <h1 class="yap module-title" id="cityseer-metrics-networks">
      <a aria-hidden="true" href="#cityseer-metrics-networks" tab_index="-1">
        <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
          xmlns="http://www.w3.org/2000/svg">
          <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
        </svg>
      </a>cityseer.metrics.networks
    </h1>
    <Markdown is:raw>
      Centrality methods
    </Markdown>
    <section class="yap func">
      <h2 class="yap func-title" id="distance-from-beta">
        <a aria-hidden="true" href="#distance-from-beta" tab_index="-1">
          <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
            xmlns="http://www.w3.org/2000/svg">
            <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
          </svg>
        </a>distance_from_beta
      </h2>
      <div class="yap func-sig-content">
        <div class="yap func-sig">
          <span>distance_from_beta(</span>
          <div class="yap func-sig-params">
            <div class="yap func-sig-param">beta, </div>
            <div class="yap func-sig-param">min_threshold_wt=(*))</div>
          </div>
        </div>
      </div>
      <div class="yap">
        <Markdown is:raw>
          Maps decay parameters $\beta$ to equivalent distance thresholds $d_{max}$ at the specified cutoff weight
          $w_{min}$.
          :::note
          It is generally not necessary to utilise this function directly. It will be called internally, if necessary,
          when invoking [`NetworkLayer`](#networklayer) or [`NetworkLayerFromNX`](#networklayerfromnx).
          :::
        </Markdown>
        <h3 class="yap">Parameters</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">beta</div>
            <div class="yap doc-str-elem-type">float | list</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              $\beta$ value/s to convert to distance thresholds $d_{max}$.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">min_threshold_wt</div>
            <div class="yap doc-str-elem-type">float</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              An optional cutoff weight $w_{min}$ at which to set the distance threshold $d_{max}$, default of
              0.01831563888873418.
            </Markdown>
          </div>
        </div>
        <h3 class="yap">Returns</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name"></div>
            <div class="yap doc-str-elem-type">np.ndarray</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              A numpy array of distance thresholds $d_{max}$.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-meta">
          <h3 class="yap">Notes</h3>
          <Markdown is:raw>
            ```python
            from cityseer.metrics import networks
            # a list of betas
            betas = [0.01, 0.02]
            # convert to distance thresholds
            d_max = networks.distance_from_beta(betas)
            print(d_max)
            # prints: array([400., 200.])
            ```


            Weighted measures such as the gravity index, weighted betweenness, and weighted land-use accessibilities are
            computed using a negative exponential decay function in the form of:

            $$weight = exp(-\beta \cdot distance)$$

            The strength of the decay is controlled by the $\beta$ parameter, which reflects a decreasing willingness to
            walk correspondingly farther distances. For example, if $\beta=0.005$ were to represent a person's
            willingness to walk to a bus stop, then a location 100m distant would be weighted at 60% and a location 400m
            away would be weighted at 13.5%. After an initially rapid decrease, the weightings decay ever more gradually
            in perpetuity; thus, once a sufficiently small weight is encountered it becomes computationally expensive to
            consider locations any farther away. The minimum weight at which this cutoff occurs is represented by
            $w_{min}$, and the corresponding maximum distance threshold by $d_{max}$.


            ![Example beta decays](/images/betas.png)

            [`NetworkLayer`](#networklayer) and [`NetworkLayerFromNX`](/metrics/networks/#networklayerfromnx) can be
            invoked with either `distances` or `betas` parameters, but not both. If using the `betas` parameter, then
            this function will be called in order to extrapolate the distance thresholds implicitly, using:

            $$d_{max} = \frac{log(w_{min})}{-\beta}$$

            The default `min_threshold_wt` of $w_{min}=0.01831563888873418$ yields conveniently rounded $d_{max}$
            walking thresholds, for example:


            | $\beta$ | $d_{max}$ |
            |:-------:|:---------:|
            | 0.02 | 200m |
            | 0.01 | 400m |
            | 0.005 | 800m |
            | 0.0025 | 1600m |


            Overriding the default $w_{min}$ will adjust the $d_{max}$ accordingly, for example:


            | $\beta$ | $w_{min}$ | $d_{max}$ |
            |:-------:|:---------:|:---------:|
            | 0.02 | 0.01 | 230m |
            | 0.01 | 0.01 | 461m |
            | 0.005 | 0.01 | 921m |
            | 0.0025 | 0.01 | 1842m |
          </Markdown>
        </div>
      </div>
    </section>
    <section class="yap func">
      <h2 class="yap func-title" id="beta-from-distance">
        <a aria-hidden="true" href="#beta-from-distance" tab_index="-1">
          <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
            xmlns="http://www.w3.org/2000/svg">
            <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
          </svg>
        </a>beta_from_distance
      </h2>
      <div class="yap func-sig-content">
        <div class="yap func-sig">
          <span>beta_from_distance(</span>
          <div class="yap func-sig-params">
            <div class="yap func-sig-param">distance, </div>
            <div class="yap func-sig-param">min_threshold_wt=(*))</div>
          </div>
        </div>
      </div>
      <div class="yap">
        <Markdown is:raw>
          Maps distance thresholds $d_{max}$ to equivalent decay parameters $\beta$ at the specified cutoff weight
          $w_{min}$. See [`distance_from_beta`](#distance-from-beta) for additional discussion.


          :::note
          It is generally not necessary to utilise this function directly. It will be called internally, if necessary,
          when invoking [`NetworkLayer`](#networklayer) or [`NetworkLayerFromNX`](#networklayerfromnx).
          :::
        </Markdown>
        <h3 class="yap">Parameters</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">distance</div>
            <div class="yap doc-str-elem-type">float | list</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              $d_{max}$ value/s to convert to decay parameters $\beta$.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">min_threshold_wt</div>
            <div class="yap doc-str-elem-type">float</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              The cutoff weight $w_{min}$ on which to model the decay parameters $\beta$, default of
              0.01831563888873418.
            </Markdown>
          </div>
        </div>
        <h3 class="yap">Returns</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name"></div>
            <div class="yap doc-str-elem-type">np.ndarray</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              A numpy array of decay parameters $\beta$.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-meta">
          <h3 class="yap">Notes</h3>
          <Markdown is:raw>
            ```python
            from cityseer.metrics import networks
            # a list of betas
            distances = [400, 200]
            # convert to betas
            betas = networks.beta_from_distance(distances)
            print(betas) # prints: array([0.01, 0.02])
            ```


            [`NetworkLayer`](#networklayer) and [`NetworkLayerFromNX`](#networklayerfromnx) can be invoked with either
            `distances` or `betas` parameters, but not both. If using the `distances` parameter, then this function will
            be called in order to extrapolate the decay parameters implicitly, using:

            $$\beta = -\frac{log(w_{min})}{d_{max}}$$

            The default `min_threshold_wt` of $w_{min}=0.01831563888873418$ yields conveniently rounded $\beta$
            parameters, for example:


            | $d_{max}$ | $\beta$ |
            |:---------:|:-------:|
            | 200m | 0.02 |
            | 400m | 0.01 |
            | 800m | 0.005 |
            | 1600m | 0.0025 |
          </Markdown>
        </div>
      </div>
    </section>
    <section class="yap func">
      <h2 class="yap func-title" id="avg-distance-for-beta">
        <a aria-hidden="true" href="#avg-distance-for-beta" tab_index="-1">
          <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
            xmlns="http://www.w3.org/2000/svg">
            <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
          </svg>
        </a>avg_distance_for_beta
      </h2>
      <div class="yap func-sig-content">
        <div class="yap func-sig">
          <span>avg_distance_for_beta(</span>
          <div class="yap func-sig-params">
            <div class="yap func-sig-param">beta, </div>
            <div class="yap func-sig-param">min_threshold_wt=(*))</div>
          </div>
        </div>
      </div>
      <div class="yap">
        <h3 class="yap">Parameters</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">beta</div>
            <div class="yap doc-str-elem-type">float | list</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              $\beta$ representing a spatial impedance / distance decay for which to compute the average walking
              distance.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name">min_threshold_wt</div>
            <div class="yap doc-str-elem-type">float</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              The cutoff weight $w_{min}$ on which to model the decay parameters $\beta$, default of
              0.01831563888873418.
            </Markdown>
          </div>
        </div>
        <h3 class="yap">Returns</h3>
        <div class="yap doc-str-elem-container">
          <div class="yap doc-str-elem-def">
            <div class="yap doc-str-elem-name"></div>
            <div class="yap doc-str-elem-type">np.ndarray</div>
          </div>
          <div class="yap doc-str-elem-desc">
            <Markdown is:raw>
              The average walking distance for a given $\beta$.
            </Markdown>
          </div>
        </div>
        <div class="yap doc-str-meta">
          <h3 class="yap">Notes</h3>
          <Markdown is:raw>
            ```python
            from cityseer.metrics import networks
            import numpy as np

            distances = np.array([100, 200, 400, 800, 1600])
            print('distances', distances)
            # distances [ 100 200 400 800 1600]

            betas = networks.beta_from_distance(distances)
            print('betas', betas)
            # betas [0.04 0.02 0.01 0.005 0.0025]

            print('avg', networks.avg_distance_for_beta(betas))
            # avg [ 35.1194952 70.2389904 140.47798079 280.95596159 561.91192318]
            ```

          </Markdown>
        </div>
      </div>
    </section>
    <section class="yap class">
      <h2 class="yap class-title" id="networklayer">
        <a aria-hidden="true" href="#networklayer" tab_index="-1">
          <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
            xmlns="http://www.w3.org/2000/svg">
            <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
          </svg>
        </a>NetworkLayer
      </h2>
      <Markdown is:raw>
        Network layers are used for network centrality computations and provide the backbone for landuse and statistical
        aggregations. [`NetworkLayerFromNX`](#networklayerfromnx) should be used instead if converting from a `NetworkX`
        `MultiGraph` to a `NetworkLayer`.

        A `NetworkLayer` requires either a set of distances $d_{max}$ or equivalent exponential decay parameters
        $\beta$, but not both. The unprovided parameter will be calculated implicitly in order to keep weighted and
        unweighted metrics in lockstep. The `min_threshold_wt` parameter can be used to generate custom mappings from
        one to the other: see [`distance_from_beta`](#distance-from-beta) for more information. These distances and
        betas are used for any subsequent centrality and land-use calculations.


        ```python
        from cityseer.metrics import networks
        from cityseer.tools import mock, graphs

        # prepare a mock graph
        G = mock.mock_graph()
        G = graphs.nx_simple_geoms(G)

        # if initialised with distances:
        # betas for weighted metrics will be generated implicitly
        N = networks.NetworkLayerFromNX(G, distances=[200, 400, 800, 1600])
        print(N.distances) # prints: [200, 400, 800, 1600]
        print(N.betas) # prints: [0.02, 0.01, 0.005, 0.0025]

        # if initialised with betas:
        # distances for non-weighted metrics will be generated implicitly
        N = networks.NetworkLayerFromNX(G, betas=[0.02, 0.01, 0.005, 0.0025])
        print(N.distances) # prints: [200, 400, 800, 1600]
        print(N.betas) # prints: [0.02, 0.01, 0.005, 0.0025]
        ```


        There are two network centrality methods available depending on whether you're using a node-based or
        segment-based approach:


        - [`node_centrality`](#networklayer-node-centrality)
        - [`segment_centrality`](#networklayer-segment-centrality)

        These methods wrap the underlying `numba` optimised functions for computing centralities, and provides access to
        all of the underlying node-based or segment-based centrality methods. Multiple selected measures and distances
        are computed simultaneously to reduce the amount of time required for multi-variable and multi-scalar
        strategies.

        See the accompanying paper on `arXiv` for additional information about methods for computing centrality
        measures.


        :::note
        The reasons for picking one approach over another are varied:


        - Node based centralities compute the measures relative to each reachable node within the threshold distances.
        For this reason, they can be susceptible to distortions caused by messy graph topologies such redundant and
        varied concentrations of degree=2 nodes (e.g. to describe roadway geometry) or needlessly complex
        representations of street intersections. In these cases, the network should first be cleaned using methods such
        as those available in the [`graph`](/tools/graphs/) module (see the [graph cleaning
        guide](/guide/#graph-cleaning) for examples/). If a network topology has varied intensities of nodes but the
        street segments are less spurious, then segmentised methods can be preferable because they are based on segment
        distances: segment aggregations remain the same regardless of the number of intervening nodes, however, are not
        immune from situations such as needlessly complex representations of roadway intersections or a proliferation of
        walking paths in greenspaces;
        - Node-based `harmonic` centrality can be problematic on graphs where nodes are erroneously placed too close
        together or where impedances otherwise approach zero, as may be the case for simplest-path measures or small
        distance thesholds. This happens because the outcome of the division step can balloon towards $\infty$ once
        impedances decrease below 1.
        - Note that `cityseer`'s implementation of simplest (angular) measures work on both primal (node or segment
        based) and dual graphs (node only).
        - Measures should only be directly compared on the same topology because different topologies can otherwise
        affect the expression of a measure. Accordingly, measures computed on dual graphs cannot be compared to measures
        computed on primal graphs because this does not account for the impact of differing topologies. Dual graph
        representations can have substantially greater numbers of nodes and edges for the same underlying street
        network; for example, a four-way intersection consisting of one node with four edges translates to four nodes
        and six edges on the dual. This effect is amplified for denser regions of the network.
        - Segmentised versions of centrality measures should not be computed on dual graph topologies because street
        segment lengths would be duplicated for each permutation of dual edge spanning street intersections. By way of
        example, the contribution of a single edge segment at a four-way intersection would be duplicated three times.
        - Global closeness is strongly discouraged because it does not behave suitably for localised graphs. Harmonic
        closeness or improved closeness should be used instead. Note that Global closeness ($\frac{nodes}{farness}$) and
        improved closeness ($\frac{nodes}{farness / nodes}$) can be recovered from the available metrics, if so desired,
        through additional (manual) steps.
        - Network decomposition can be a useful strategy when working at small distance thresholds, and confers
        advantages such as more regularly spaced snapshots and fewer artefacts at small distance thresholds where street
        edges intersect distance thresholds. However, the regular spacing of the decomposed segments will introduce
        spikes in the distributions of node-based centrality measures when working at very small distance thresholds.
        Segmentised versions may therefore be preferable when working at small thresholds on decomposed networks.
        :::


        The computed metrics will be written to a dictionary available at the `NetworkLayer.metrics` property and will
        be categorised by the respective centrality and distance keys:


        ```python
        NetworkLayer.metrics.centrality[measure_key][distance_key][node_idx]
        ```


        For example, if `node_density`, and `node_betweenness_beta` centrality keys are computed at 800m and 1600m, then
        the dictionary would assume the following structure:


        ```python
        # example structure
        NetworkLayer.metrics = {
        'centrality': {
        'node_density': {
        800: [np.ndarray],
        1600: [np.ndarray]
        },
        'node_betweenness_beta': {
        800: [np.ndarray],
        1600: [np.ndarray]
        }
        }
        }
        ```


        A worked example:


        ```python
        from cityseer.metrics import networks
        from cityseer.tools import mock, graphs

        # prepare a mock graph
        G = mock.mock_graph()
        G = graphs.nx_simple_geoms(G)

        # generate the network layer and compute some metrics
        N = networks.NetworkLayerFromNX(G, distances=[200, 400, 800, 1600])
        # compute a centrality measure
        N.node_centrality(measures=['node_density', 'node_betweenness_beta'])

        # fetch node density for 400m threshold for the first 5 nodes
        print(N.metrics.centrality['node_density'][400][:5])
        # prints [15, 13, 10, 11, 12]

        # fetch betweenness beta for 1600m threshold for the first 5 nodes
        print(N.metrics.centrality['node_betweenness_beta'][1600][:5])
        # prints [76.01161, 45.261307, 6.805982, 11.478158, 33.74703]
        ```


        The data can be handled using the underlying `numpy` arrays, and can also be unpacked to a dictionary using
        [`NetworkLayer.metrics_to_dict`](#networklayer-metrics-to-dict) or transposed to a `networkX` graph using
        [`NetworkLayer.to_nx_multigraph`](#networklayer-to-networkx).
      </Markdown>
      <h3 class="yap">Properties</h3>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">uids</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">distances</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">betas</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">node_x_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">node_y_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">node_live_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">edge_lengths_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">edge_angles_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">edge_impedance_factors_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">edge_in_bearings_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">edge_out_bearings_arr</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <div class="yap class-prop-elem-container">
        <div class="yap class-prop-def">
          <div class="yap class-prop-def-name">nx_multigraph</div>
          <div class="yap class-prop-def-type"></div>
        </div>
        <div class="yap class-prop-def-desc"></div>
      </div>
      <h3 class="yap">Methods</h3>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-init">
          <a aria-hidden="true" href="#networklayer-init" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.__init__
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.__init__(</span>
            <div class="yap func-sig-params">
              <div class="yap func-sig-param">node_uids, </div>
              <div class="yap func-sig-param">node_data, </div>
              <div class="yap func-sig-param">edge_data, </div>
              <div class="yap func-sig-param">node_edge_map, </div>
              <div class="yap func-sig-param">distances, </div>
              <div class="yap func-sig-param">betas, </div>
              <div class="yap func-sig-param">min_threshold_wt=(*))</div>
            </div>
          </div>
        </div>
        <div class="yap">
          <h3 class="yap">Parameters</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">node_uids</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `list` or `tuple` of node identifiers corresponding to each node. This list must be in the same order
                and of the same length as the `node_data`.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">node_data</div>
              <div class="yap doc-str-elem-type"></div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A 2d `numpy` array representing the graph's nodes. The indices of the second dimension correspond as
                follows:


                | idx | property |
                |:---:|:---------|
                | 0 | `x` coordinate |
                | 1 | `y` coordinate |
                | 2 | `bool` describing whether the node is `live`. Metrics are only computed for `live` nodes. |


                The `x` and `y` node attributes determine the spatial coordinates of the node, and should be in a
                suitable projected (flat) coordinate reference system in metres.
                [`nx_wgs_to_utm`](/tools/graphs/#nx-wgs-to-utm) can be used for converting a `networkX` graph from WGS84
                `lng`, `lat` geographic coordinates to the local UTM `x`, `y` projected coordinate system.

                When calculating local network centralities or land-use accessibilities, it is best-practice to buffer
                the network by a distance equal to the maximum distance threshold to be considered. This prevents
                problematic results arising due to boundary roll-off effects.

                The `live` node attribute identifies nodes falling within the areal boundary of interest as opposed to
                those that fall within the surrounding buffered area. Calculations are only performed for `live=True`
                nodes, thus reducing frivolous computation while also cleanly identifying which nodes are in the
                buffered roll-off area. If some other process will be used for filtering the nodes, or if boundary
                roll-off is not being considered, then set all nodes to `live=True`.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">edge_data</div>
              <div class="yap doc-str-elem-type"></div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A 2d `numpy` array representing the graph's edges. Each edge will be described separately for each
                direction of travel. The indices of the second dimension correspond as follows:


                | idx | property |
                |:---:|:---------|
                | 0 | start node `idx` |
                | 1 | end node `idx` |
                | 2 | the segment length in metres |
                | 3 | the sum of segment's angular change |
                | 4 | an 'impedance factor' which can be applied to magnify or reduce the effect of the edge's impedance
                on shortest-path calculations. e.g. for gradients or other such considerations. Use with caution. |
                | 5 | the edge's entry angular bearing |
                | 6 | the edge's exit angular bearing |


                The start and end edge `idx` attributes point to the corresponding node indices in the `node_data`
                array.

                The `length` edge attribute (index 2) should always correspond to the edge lengths in metres. This is
                used when calculating the distances traversed by the shortest-path algorithm so that the respective
                $d_{max}$ maximum distance thresholds can be enforced: these distance thresholds are based on the actual
                network-paths traversed by the algorithm as opposed to crow-flies distances.

                The `angle_sum` edge bearing (index 3) should correspond to the total angular change along the length of
                the segment. This is used when calculating angular impedances for simplest-path measures. The
                `start_bearing` (index 5) and `end_bearing` (index 6) attributes respectively represent the starting and
                ending bearing of the segment. This is also used when calculating simplest-path measures when the
                algorithm steps from one edge to another.

                The `imp_factor` edge attribute (index 4) represents an impedance multiplier for increasing or
                diminishing the impedance of an edge. This is ordinarily set to 1, therefor not impacting calculations.
                By setting this to greater or less than 1, the edge will have a correspondingly higher or lower
                impedance. This can be used to take considerations such as street gradients into account, but should be
                used with caution.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">node_edge_map</div>
              <div class="yap doc-str-elem-type">Dict</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `numba` `Dict` with `node_data` indices as keys and `numba` `List` types as values containing the
                out-edge indices for each node.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">distances</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A distance, or `list`, `tuple`, or `numpy` array of distances corresponding to the local $d_{max}$
                thresholds to be used for centrality (and land-use) calculations. The $\beta$ parameters (for
                distance-weighted metrics) will be determined implicitly. If the `distances` parameter is not provided,
                then the `beta` parameter must be provided instead. Use a distance of `np.inf` where no distance
                threshold should be enforced.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">betas</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A $\beta$, or `list`, `tuple`, or `numpy` array of $\beta$ to be used for the exponential decay function
                for weighted metrics. The `distance` parameters for unweighted metrics will be determined implicitly. If
                the `betas` parameter is not provided, then the `distance` parameter must be provided instead.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">min_threshold_wt</div>
              <div class="yap doc-str-elem-type">float</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                The default `min_threshold_wt` parameter can be overridden to generate custom mappings between the
                `distance` and `beta` parameters. See [`distance_from_beta`](#distance-from-beta) for more information.
              </Markdown>
            </div>
          </div>
          <h3 class="yap">Returns</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name"></div>
              <div class="yap doc-str-elem-type">NetworkLayer</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `NetworkLayer`.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-meta">
            <h3 class="yap">Notes</h3>
            <Markdown is:raw>
              :::note
              It is possible to represent unlimited $d_{max}$ distance thresholds by setting one of the specified
              `distance` parameter values to `np.inf`. Note that this may substantially increase the computational time
              required for the completion of the algorithms on large networks.
              :::


              Properties
              ----------
            </Markdown>
          </div>
        </div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-networkx-multigraph">
          <a aria-hidden="true" href="#networklayer-networkx-multigraph" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.nx_multigraph
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.nx_multigraph(</span>
            <div class="yap func-sig-params">
              <div class="yap func-sig-param">nx_multigraph)</div>
            </div>
          </div>
        </div>
        <div class="yap"></div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-metrics-to-dict">
          <a aria-hidden="true" href="#networklayer-metrics-to-dict" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.metrics_to_dict
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.metrics_to_dict(</span>
            <div class="yap func-sig-params"></div>
          </div>
        </div>
        <div class="yap">
          <Markdown is:raw>
            Unpacks all calculated metrics from the `NetworkLayer.metrics` property into a `python` dictionary. The
            dictionary `keys` will correspond to the node `uids`.
          </Markdown>
          <div class="yap doc-str-meta">
            <h3 class="yap">Notes</h3>
            <Markdown is:raw>
              ```python
              from cityseer.metrics import networks
              from cityseer.tools import mock, graphs

              # prepare a mock graph
              G = mock.mock_graph()
              G = graphs.nx_simple_geoms(G)

              # generate the network layer and compute some metrics
              N = networks.NetworkLayerFromNX(G, distances=[200, 400, 800, 1600])
              N.node_centrality(measures=['node_harmonic'])

              # let's select a random node id
              random_idx = 6
              random_nd_key = N.uids[random_idx]

              # the data is directly available at N.metrics
              # in this case the data is stored in arrays corresponding to the node indices
              print(N.metrics.centrality['node_harmonic'][200][random_idx])
              # prints: 0.023120252

              # let's convert the data to a dictionary
              # the unpacked data is now stored by the uid of the node identifier
              data_dict = N.metrics_to_dict()
              print(data_dict[random_uid].centrality['node_harmonic'][200])
              # prints: 0.023120252
              ```

            </Markdown>
          </div>
        </div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-to-networkx">
          <a aria-hidden="true" href="#networklayer-to-networkx" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.to_nx_multigraph
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.to_nx_multigraph(</span>
            <div class="yap func-sig-params"></div>
          </div>
        </div>
        <div class="yap">
          <Markdown is:raw>
            Transposes a `NetworkLayer` into a `networkX` `MultiGraph`. This method calls
            [`nx_from_network_structure`](/tools/graphs/#nx-from-graph-maps) internally.
          </Markdown>
          <h3 class="yap">Returns</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name"></div>
              <div class="yap doc-str-elem-type">nx.MultiGraph</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `networkX` `MultiGraph`.

                `x`, `y`, and `live` node attributes will be copied from `node_data` to the `MultiGraph` nodes.
                `length`, `angle_sum`, `imp_factor`, `start_bearing`, and `end_bearing` attributes will be copied from
                the `edge_data` to the `MultiGraph` edges.

                If a `metrics_dict` is provided, all derived data will be copied to the `MultiGraph` nodes based on
                matching node identifiers.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-meta">
            <h3 class="yap">Notes</h3>
            <Markdown is:raw>
              ```python
              from cityseer.metrics import networks
              from cityseer.tools import mock, graphs

              # prepare a mock graph
              G = mock.mock_graph()
              G = graphs.nx_simple_geoms(G)

              # generate the network layer and compute some metrics
              N = networks.NetworkLayerFromNX(G, distances=[200, 400, 800, 1600])
              # compute some-or-other metrics
              N.node_centrality(measures=['node_harmonic'])
              # convert back to networkX
              G_post = N.to_nx_multigraph()

              # let's select a random node id
              random_idx = 6
              random_uid = N.uids[random_idx]

              print(N.metrics.centrality['node_harmonic'][200][random_idx])
              # prints: 0.023120252

              # the metrics have been copied to the new networkX graph
              print(G_post.nodes[random_uid]['metrics'].centrality['node_harmonic'][200])
              # prints: 0.023120252
              ```

              ![Graph before conversion](/images/graph_before.png) _A `networkX` graph before conversion to a
              `NetworkLayer`._
              ![Graph after conversion back to networkX](/images/graph_after.png) _A graph after conversion back to
              `networkX`._
            </Markdown>
          </div>
        </div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-compute-centrality">
          <a aria-hidden="true" href="#networklayer-compute-centrality" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.compute_centrality
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.compute_centrality(</span>
            <div class="yap func-sig-params"></div>
          </div>
        </div>
        <div class="yap">
          <Markdown is:raw>
            This method is deprecated and, if invoked, will raise a DeprecationWarning. Please use
            [`node_centrality`](#networklayer-node-centrality) or
            [`segment_centrality`](#networklayer-segment-centrality) instead.
          </Markdown>
        </div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-node-centrality">
          <a aria-hidden="true" href="#networklayer-node-centrality" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.node_centrality
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.node_centrality(</span>
            <div class="yap func-sig-params">
              <div class="yap func-sig-param">measures, </div>
              <div class="yap func-sig-param">jitter_scale=0.0, </div>
              <div class="yap func-sig-param">angular=False)</div>
            </div>
          </div>
        </div>
        <div class="yap">
          <h3 class="yap">Parameters</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">measures</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A list or tuple of strings, containing any combination of the following `key` values, computed within
                the respective distance thresholds of $d_{max}$.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">jitter_scale</div>
              <div class="yap doc-str-elem-type">float</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                The scale of random jitter to add to shortest path calculations, useful for situations with highly
                rectilinear grids. `jitter_scale` is passed to the `scale` parameter of `np.random.normal`. Default of
                zero.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">angular</div>
              <div class="yap doc-str-elem-type">bool</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A boolean indicating whether to use shortest or simplest path heuristics, by default False
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-meta">
            <h3 class="yap">Notes</h3>
            <Markdown is:raw>
              The following keys use the shortest-path heuristic, and are available when the `angular` parameter is set
              to the default value of `False`:


              | key | formula | notes |
              | ----------------------| :------:| ----- |
              | node_density | $$\sum_{j\neq{i}}^{n}1$$ | A summation of nodes. |
              | node_farness | $$\sum_{j\neq{i}}^{n}d_{(i,j)}$$ | A summation of distances in metres. |
              | node_cycles | $$\sum_{j\neq{i}j=cycle}^{n}1$$ | A summation of network cycles. |
              | node_harmonic | $$\sum_{j\neq{i}}^{n}\frac{1}{Z_{(i,j)}}$$ | Harmonic closeness is an appropriate form
              of closeness centrality for localised implementations constrained by the threshold $d_{max}$. |
              | node_beta | $$\sum_{j\neq{i}}^{n}\exp(-\beta\cdot d[i,j])$$ | Also known as the '_gravity index_'. This
              is a spatial impedance metric differentiated from other closeness centralities by the use of an explicit
              $\beta$ parameter, which can be used to model the decay in walking tolerance as distances increase. |
              | node_betweenness | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}1$$ | Betweenness centrality summing
              all shortest-paths traversing each node $i$. |
              | node_betweenness_beta | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}\exp(-\beta\cdot d[j,k])$$ |
              Applies a spatial impedance decay function to betweenness centrality. $d$ represents the full distance
              from any $j$ to $k$ node pair passing through node $i$. |


              The following keys use the simplest-path (shortest-angular-path) heuristic, and are available when the
              `angular` parameter is explicitly set to `True`:


              | key | formula | notes |
              | ------------------------ | :-----: | ----- |
              | node_harmonic_angular | $$\sum_{j\neq{i}}^{n}\frac{1}{Z_{(i,j)}}$$ | The simplest-path implementation of
              harmonic closeness uses angular-distances for the impedance parameter. Angular-distances are normalised by
              180 and added to 1 to avoid division by zero: ${Z = 1 + (angularchange/180)}$. |
              | node_betweenness_angular | $$\sum_{j\neq{i}}^{n}\sum_{k\neq{j}\neq{i}}^{n}1$$ | The simplest-path
              version of betweenness centrality. This is distinguished from the shortest-path version by use of a
              simplest-path heuristic (shortest angular distance). |
            </Markdown>
          </div>
        </div>
      </section>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayer-segment-centrality">
          <a aria-hidden="true" href="#networklayer-segment-centrality" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayer.segment_centrality
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayer.segment_centrality(</span>
            <div class="yap func-sig-params">
              <div class="yap func-sig-param">measures, </div>
              <div class="yap func-sig-param">jitter_scale=0.0, </div>
              <div class="yap func-sig-param">angular=False)</div>
            </div>
          </div>
        </div>
        <div class="yap">
          <Markdown is:raw>
            A list or tuple of strings, containing any combination of the following `key` values, computed within the
            respective distance thresholds of $d_{max}$.
          </Markdown>
          <h3 class="yap">Parameters</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">measures</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A list or tuple of strings, containing any combination of the following `key` values, computed within
                the respective distance thresholds of $d_{max}$.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">jitter_scale</div>
              <div class="yap doc-str-elem-type">float</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                The scale of random jitter to add to shortest path calculations, useful for situations with highly
                rectilinear grids. `jitter_scale` is passed to the `scale` parameter of `np.random.normal`. Default of
                zero.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">angular</div>
              <div class="yap doc-str-elem-type">bool</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A boolean indicating whether to use shortest or simplest path heuristics, by default False
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-meta">
            <h3 class="yap">Notes</h3>
            <Markdown is:raw>
              The following keys use the shortest-path heuristic, and are available when the `angular` parameter is set
              to the default value of `False`:


              | key | formula | notes |
              | ------------------- | :-----: |------ |
              | segment_density | $$\sum_{(a, b)}^{edges}d_{b} - d_{a}$$ | A summation of edge lengths. |
              | segment_harmonic | $$\sum_{(a, b)}^{edges}\int_{a}^{b}\ln(b) -\ln(a)$$ | A continuous form of harmonic
              closeness centrality applied to edge lengths. |
              | segment_beta | $$\sum_{(a, b)}^{edges}\int_{a}^{b}\frac{\exp(-\beta\cdot b) -\exp(-\beta\cdot
              a)}{-\beta}$$ | A continuous form of beta-weighted (gravity index) centrality applied to edge lengths. |
              | segment_betweenness | | A continuous form of betweenness: Resembles `segment_beta` applied to edges
              situated on shortest paths between all nodes $j$ and $k$ passing through $i$. |


              The following keys use the simplest-path (shortest-angular-path) heuristic, and are available when the
              `angular` parameter is explicitly set to `True`.


              | key | formula | notes |
              | ------------------------- | :-----: | ----- |
              | segment_harmonic_hybrid | $$\sum_{(a, b)}^{edges}\frac{d_{b} - d_{a}}{Z}$$ | Weights angular harmonic
              centrality by the lengths of the edges. See `node_harmonic_angular`. |
              | segment_betweeness_hybrid | | A continuous form of angular betweenness: Resembles
              `segment_harmonic_hybrid` applied to edges situated on shortest paths between all nodes $j$ and $k$
              passing through $i$. |
            </Markdown>
          </div>
        </div>
      </section>
    </section>
    <section class="yap class">
      <h2 class="yap class-title" id="networklayerfromnx">
        <a aria-hidden="true" href="#networklayerfromnx" tab_index="-1">
          <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
            xmlns="http://www.w3.org/2000/svg">
            <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
          </svg>
        </a>NetworkLayerFromNX
      </h2>
      <p class="yap class-base">Inherits from
        <a href="#networklayer">NetworkLayer</a>.
      </p>
      <h3 class="yap">Methods</h3>
      <section class="yap func">
        <h2 class="yap func-title" id="networklayerfromnx-init">
          <a aria-hidden="true" href="#networklayerfromnx-init" tab_index="-1">
            <svg ariaHidden="true" class="heading-icon" height="15px" viewbox="0 0 20 20" width="15px"
              xmlns="http://www.w3.org/2000/svg">
              <path clip-rule="evenodd" d="
M12.586 4.586a2 2 0 112.828 2.828l-3 3a2 2 0 01-2.828 0 1 1 0 00-1.414 1.414 4 4 0 005.656 0l3-3a4 4 0 00-5.656-5.656l-1.5 1.5a1 1 0 101.414 1.414l1.5-1.5zm-5 5a2 2 0 012.828 0 1 1 0 101.414-1.414 4 4 0 00-5.656 0l-3 3a4 4 0 105.656 5.656l1.5-1.5a1 1 0 10-1.414-1.414l-1.5 1.5a2 2 0 11-2.828-2.828l3-3z
" fill-rule="evenodd"></path>
            </svg>
          </a>NetworkLayerFromNX.__init__
        </h2>
        <div class="yap func-sig-content">
          <div class="yap func-sig">
            <span>NetworkLayerFromNX.__init__(</span>
            <div class="yap func-sig-params">
              <div class="yap func-sig-param">nx_multigraph, </div>
              <div class="yap func-sig-param">distances, </div>
              <div class="yap func-sig-param">betas, </div>
              <div class="yap func-sig-param">min_threshold_wt=(*))</div>
            </div>
          </div>
        </div>
        <div class="yap">
          <Markdown is:raw>
            Directly transposes a `networkX` `MultiGraph` into a `NetworkLayer`. This `class` simplifies the conversion
            of a `NetworkX` `MultiGraph` by calling [`network_structure_from_nx`](/tools/graphs/#graph-maps-from-nx)
            internally. Methods and properties are inherited from the parent [`NetworkLayer`](#networklayer) class.
          </Markdown>
          <h3 class="yap">Parameters</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">nx_multigraph</div>
              <div class="yap doc-str-elem-type"></div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `networkX` `MultiGraph`.

                `x` and `y` node attributes are required. The `live` node attribute is optional, but recommended. See
                [`NetworkLayer`](#networklayer) for more information about what these attributes represent.
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">distances</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                See [`NetworkLayer`](#networklayer).
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">betas</div>
              <div class="yap doc-str-elem-type">list | tuple</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                See [`NetworkLayer`](#networklayer).
              </Markdown>
            </div>
          </div>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name">min_threshold_wt</div>
              <div class="yap doc-str-elem-type">float</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                See [`NetworkLayer`](#networklayer).
              </Markdown>
            </div>
          </div>
          <h3 class="yap">Returns</h3>
          <div class="yap doc-str-elem-container">
            <div class="yap doc-str-elem-def">
              <div class="yap doc-str-elem-name"></div>
              <div class="yap doc-str-elem-type">NetworkLayer</div>
            </div>
            <div class="yap doc-str-elem-desc">
              <Markdown is:raw>
                A `NetworkLayer`.
              </Markdown>
            </div>
          </div>
        </div>
      </section>
    </section>
  </div>
</PageLayout>