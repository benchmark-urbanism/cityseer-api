#!/usr/bin/env python
"""
Sync sampling model constants from analysis output to config.py.

This script reads the fitted model parameters from sampling_model_constants.json
(generated by sampling_analysis.py) and updates the constants in config.py.

Usage:
    python analysis/sync_sampling_constants.py
"""

import json
import re
from pathlib import Path

# Paths
SCRIPT_DIR = Path(__file__).parent
CONSTANTS_FILE = SCRIPT_DIR / "output" / "sampling_model_constants.json"
CONFIG_FILE = SCRIPT_DIR.parent / "pysrc" / "cityseer" / "config.py"


def main():
    # Load the model constants
    if not CONSTANTS_FILE.exists():
        print(f"Note: Constants file not found: {CONSTANTS_FILE}")
        print("Run sampling_analysis.py first to generate the model constants.")
        print("Skipping sync (this is not an error).")
        return 0  # Don't fail - just skip if file doesn't exist

    with open(CONSTANTS_FILE) as f:
        constants = json.load(f)

    print(f"Loaded constants from: {CONSTANTS_FILE}")
    print(f"  Generated: {constants['generated']}")

    # Handle both old (int) and new (dict) data_points format
    data_points = constants["data_points"]
    if isinstance(data_points, dict):
        h_count = data_points.get("harmonic", "?")
        b_count = data_points.get("betweenness", "?")
        print(f"  Data points: harmonic={h_count}, betweenness={b_count}")
    else:
        print(f"  Data points: {data_points}")

    # Print conservative percentile if present
    if "conservative_percentile" in constants:
        print(f"  Conservative percentile: {constants['conservative_percentile']}th")

    # Extract values (uses primary rho_model which is betweenness conservative)
    rho_a = constants["rho_model"]["A"]
    rho_b = constants["rho_model"]["B"]
    std_c = constants["std_model"]["C"]
    std_d = constants["std_model"]["D"]
    bias_e = constants.get("bias_model", {}).get("E", 0.46)
    bias_f = constants.get("bias_model", {}).get("F", -0.13)

    print("\nPrimary model parameters (betweenness conservative):")
    print(f"  Rho: A={rho_a}, B={rho_b}")
    print(f"  Std: C={std_c}, D={std_d}")
    print(f"  Bias: E={bias_e}, F={bias_f}")

    # Show metric-specific models if available
    if "harmonic_model" in constants and "betweenness_model" in constants:
        print("\nMetric-specific models:")
        h = constants["harmonic_model"]
        b = constants["betweenness_model"]
        print(f"  Harmonic:    A={h['A']}, B={h['B']}")
        print(f"  Betweenness: A={b['A']}, B={b['B']}")

    # Extract metric-specific models if available
    harmonic_a = constants.get("harmonic_model", {}).get("A", rho_a)
    harmonic_b = constants.get("harmonic_model", {}).get("B", rho_b)
    betweenness_a = constants.get("betweenness_model", {}).get("A", rho_a)
    betweenness_b = constants.get("betweenness_model", {}).get("B", rho_b)

    # Read config.py
    config_content = CONFIG_FILE.read_text()

    # Define patterns and replacements
    updates = [
        # Metric-specific rho models
        ("SAMPLING_MODEL_HARMONIC_A", harmonic_a),
        ("SAMPLING_MODEL_HARMONIC_B", harmonic_b),
        ("SAMPLING_MODEL_BETWEENNESS_A", betweenness_a),
        ("SAMPLING_MODEL_BETWEENNESS_B", betweenness_b),
        # Std and bias models
        ("SAMPLING_MODEL_STD_C", std_c),
        ("SAMPLING_MODEL_STD_D", std_d),
        ("SAMPLING_MODEL_BIAS_E", bias_e),
        ("SAMPLING_MODEL_BIAS_F", bias_f),
    ]

    print("\nUpdating config.py:")
    updated = False
    for var_name, new_value in updates:
        # Pattern to match the variable assignment (handles negative numbers)
        pattern = rf"^({var_name}: float = )-?[\d.]+(.*)$"
        replacement = rf"\g<1>{new_value}\2"

        new_content, count = re.subn(pattern, replacement, config_content, flags=re.MULTILINE)
        if count > 0:
            config_content = new_content
            updated = True
            print(f"  Updated {var_name} = {new_value}")
        else:
            print(f"  Warning: Could not find {var_name} in config.py")

    if updated:
        CONFIG_FILE.write_text(config_content)
        print(f"\nUpdated: {CONFIG_FILE}")
    else:
        print("\nNo updates made.")

    return 0


if __name__ == "__main__":
    exit(main())
